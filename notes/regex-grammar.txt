'|'
'.'
'('
')'
'['
'[^'
']'
'a-b'
'{'
'}'

regex       = expr eof { regex };
sub         = expr ')' ;
expr        = alt alts ;
alts        = '|' alt { alt } alts
            | $empty;
alt         = { empty } factor factors
            | { empty } $empty;
factors     = factor { cat } factors
            | $empty;
char_class  = ranges ']' { char_class }
ranges      = 'a-z' { range } ranges
            | $empty;
factor      = '(' sub { sub } unops
            | '{' id '}' { id } unops
            | '[' char_class unops
            | '[^' char_class { neg_char_class } unops
            | '.' { dotall } unops
            | a { sym } unops;
unops       = '*' { star } unops
            | '+' { plus } unops
            | '?' { optional } unops
            | '{' number '}' { repeat_exact } unops
            | $empty;

REGEX       ->EXPR eof .
EXPR        -> ALT ALTS | .
ALTS        -> alt ALT ALTS | .
ALT         -> FACTOR FACTORS .
FACTORS     -> FACTOR FACTORS | .
CHAR_CLASS  -> RANGES rbracket .
RANGES      -> range RANGES | .
FACTOR      -> lparen EXPR rparen UNOPS
            | id_brace id rbrace UNOPS
            | lclass CHAR_CLASS UNOPS
            | lneg CHAR_CLASS UNOPS
            | dotall UNOPS
            | a UNOPS .
UNOPS       -> star UNOPS
            | plus UNOPS
            | optional UNOPS
            | lbrace number rbrace UNOPS
            | .

character class ideas:
1. Alternatives
    - add a single "range" or "interval" state
    - merge and sort from the class during parsing, i.e.:
        [a-zde0-53-934]
        [a-h d e 0-5 3-9 3 4]
        [a-h 0-9]
        [a-z0-9]
    - if a negated class, invert the above merged and sorted interval list
    - create a machine from the list of intervals as branching machines of range
      and symbol states
    - PROS: simulation logic only needs to consider single range or symbol at a time
    - CONS: potentially many more states, for alphabet a-z,
        [^a] would then create 25 symbol states and 24 branching states

2. Single State
    - list of merged and sorted intervals directly on the state
    - PROS: single state
    - CONS: simulation logic is more complex, requires a loop


REGEX       -> EXPR eof .
SUB         -> EXPR rparen .
EXPR        -> ALT ALTS .
ALTS        -> alt ALT ALTS | .
ALT         -> FACTOR FACTORS | .
FACTORS     -> FACTOR FACTORS | .
CHAR_CLASS  -> RANGES rbracket .
RANGES      -> range RANGES | .
FACTOR      -> lparen SUB UNOPS
            | id_brace id rbrace UNOPS
            | lclass CHAR_CLASS UNOPS
            | lneg CHAR_CLASS UNOPS
            | dotall UNOPS
            | a UNOPS .
UNOPS       -> star UNOPS
            | plus UNOPS
            | optional UNOPS
            | lbrace number rbrace UNOPS
            | .



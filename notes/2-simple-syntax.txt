2. A Simple Syntax Directed Translator

fragment:
{
    int i; 
    int j; 
    float[100] a; 
    float v;
    float x;

    while (true) {
        do i = i+1; while (a[i] < v);
        do j = j-1; while (a[j] > v);
        if (i >= j) break;
        x = a[i]; a[i] = a[j]; a[j] = x;
    }
}

intermediate representation:
1. i = i + 1
2. t1 = a[i]
3. if t1 < v goto 1
4. j = j - 1
5. t2 = a[j]
6. if t2 > v goto 4
7. ifFalse i >= j goto 9
8. goto 14
9. x = a[i]
10. t3 = a[j]
11. a[i] = t3
12. a[j] = x
13. goto 1
14.

Context Free Grammar
Backus-Naur Form

Infix Form:
9 - 5 + 2

Postfix Form:
9 5 - 2 +

Lexical Analyzer - Splits input into basic units for syntax analysis called tokens
Intermediate Code Generation - 
    Syntax Trees, a representation of the source program
    Three Address Code, an intermediate structure

Three Address Code:
Named because it's instructions are of the form x = y `op` z
Where x, y, and z are the addresses of the operands and the result

Production rules:
An if expression of the form:
if (expression) statement else statement

Can be described using the following production:
stmt -> "if" '(' expr ')' stmt "else" stmt
"if", '(', ')', and "else" are terminal symbols
stmt and expr are non-terminal symbols

A CFG has four components:
1. Terminals
2. Non-Terminals
3. Productions
4. A Start Symbol 

For example:
list: list '+' digit 
    | list '-' digit
    | digit

terminals:
+ - 0 1 2 3 4 5 6 7 8 9 

epsilon:
ε - string of zero terminals, the empty string

Parse Trees:
A: X Y Z
        A          
  +---  |  ---+  
  |     |     |  
  X     Y     Z  

A: X Y 
 | Z
        A               A  
  +---     ---+         |  
  |           |         |  
  X           Y         Z  

ambiguity
a grammar can have more than one parse tree for a string of terminals

** to show that a grammar is ambiguous, all we need to do is show that a terminal string
   is the **yield** of more than one parse tree **

for example:
string: string + string
      | string - string
      | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

        string                   string                           string                 
    +--    |   ---+          +--    |   ---+                         |                   
    |      |      |          |      |      |                         |                   
 string    +   string     string    -   string     0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 

associativity of 9 - 5 + 2

Parse Trees
(9 - 5) + 2
                       string        
           +----------    |   ---+   
           |              |      |   
        string            |   string 
    +--    |   ---+       |      |   
    |      |      |       |      |   
 string    |   string     |      |   
    |      |      |       |      |   
    |      |      |       |      |   
    9      -      5       +      2          <--- the "yield" of terminals
                                     
9 - (5 + 2)
        string                       
    +--    |   -----------+          
    |      |              |          
    |      |           string        
    |      |      +---    |   ---+   
    |      |      |       |      |   
 string    |   string     |   string 
    |      |      |       |      |   
    |      |      |       |      |   
    9      -      5       +      2          <--- the "yield" of terminals   

Ex. 2.2.1
S : S S '+' 
  | S S '*' 
  | 'a'
a) aa+a*
    1. a = S: 'a'
    2. b = S: 'a'
    3. c = S: a b '+'
    4. d = S: 'a'
    5. e = c d '*'

Syntax Directed Translation
- Attributes
- Translation Schemes

Syntax Directed Definition Associates:
1. For each grammar symbol, a set of attributes
2. For each production, a set of semantic rules for puting the values of the attributes

X = the label for the grammar symbol at a particular node
X.a = attribute a for grammar symbol X

expr = 9 - 5 + 2
expr.t = 95-2+

                    expr.t = 95-2+
           +----------    |   ---+   
           |              |      |   
      expr.t = 95-        |   term.t = 2
    +--    |   ---+       |      |   
expr.t = 9 |      |       |      |   
    |      | term.t = 5   |      |   
term.t = 9 |      |       |      |   
    |      |      |       |      |   
    9      -      5       +      2          

Infix to Postfix:

Production              Semantic Rules
expr: expr₁ + term      expr.t = expr₁.t <> term.t <> +
expr: expr₁ - term      expr.t = expr₁.t <> term.t <> -
expr: term              expr.t = term.t
term: 0 | 1 | ...       term.t = 0 | 1 | ...

Tree Traversals:
Pre-Order
Post-Order
In-Order

Depth vs Breadth

Any bottom-up order can be used for a syntax directed definition, because node N _depends_ on it's children,
and so simply evaluating the children in any order is good enough.

Pre vs Post
void visit(node) {
    // pre-order
    for (int i = 0; i < length(node->children); i++) {
        visit(node->children[i]);
    }
    // post-order
}


Semantic Actions:
expr: expr₁ + term { print('+') }
expr: expr₁ - term { print('+') }
expr: term 
term: 0 | 1 | ...  { print('N') }


                      +------------------------------------  expr  ----------------------------------+       
                      |                                        |  |                                  |       
                      |                                        |  |                                  |       
                    expr  -----------------------------+       |  +--------------+                   |       
       +----------    |   ---------+                   |       |                 |                   |       
       |              |            |                   |       |                 |                   |       
       |              |            |                   |       |                 |                   |       
     expr             |          term                  |       |               term                  |       
       |              |            |                   |       |                 |                   |       
       |              |            |                   |       |                 |                   |       
     term             |            |                   |       |                 |                   |       
       |              |       +----+                   |       |            +----+                   |       
  +----+              |       |    |                   |       |            |    |                   |       
  |    |              |       |    |                   |       |            |    |                   |       
  |    |              |       |    |                   |       |            |    |                   |       
  9    |              -       5    |                   |       +            2    |                   |       
       |                           |                   |                         |                   |       
       |                           |                   |                         |                   |       
{ print ('9') }             { print ('5') }     { print ('-') }           { print ('2') }     { print ('+') }


**Semantically, this prints the translation as the tree is traversed, whereas 
the above semantics (with <>) builds up a string to be a printed.**

We could also have built up a full AST if we needed to. Lots of possibilities with semantic actions. 

AST Example:
data Expr
    = Add Expr Term
    | Sub Expr Term
    | Term Int    

Parsing
The process of determining how a string of terminals can be generated by a grammar

Recursive Descent Parsing
- One procedure for each non-terminal symbol, generally

Worst case scenario for a Parser for a Context Free Grammar is O(n^3) for a string of n terminals
For real languages, Context Free Grammars are designed to be much faster than this. The key
being that the Context Free Grammar determines the speed at which parsing is possible.

** TODO: Find out what kind of grammar takes O(n^3) steps to parse **

Parsing usually falls into two categories:
top-down - construction starts at the root and proceeds towards the leaves
bottom-up - construction starts at the leaves and proceeds up towards the root

top-down example:
start: stmt

stmt: expr ';'
    | "if" '(' expr ')' stmt
    | "for" '(' optexpr ';' optexpr ';' optexpr ')' stmt
    | "other"

optexpr: ε
       | expr

lookahead symbol: 
initially the first terminals of a string
then successive terminals after that

The process of trying production rules may involve backtracking:

For terminal string:
for ( ; expr ; expr ) other
 ↑  // lookahead

// doesn't begin with "expr", backtrack 1
-> "expr" ';'                     
   "if" '(' "expr" ')' stmt
   "for" '(' optexpr ';' optexpr ';' optexpr ')' stmt
   "other"

// doesn't begin with "if", backtrack 1
   "expr" ';'                     
-> "if" '(' "expr" ')' stmt
   "for" '(' optexpr ';' optexpr ';' optexpr ')' stmt
   "other"

// sweet, we found a production that begins with "for"
// try match the rest
   "expr" ';'                     
   "if" '(' "expr" ')' stmt
-> "for" '(' optexpr ';' optexpr ';' optexpr ')' stmt
   "other"

Predictive Parsing
The simplest form of recursive descent parsing, where the lookahead symbol
is guaranteed to uniquely determine the flow of control. The sequence of procedure
calls forms an implicit parse tree that can be used to form an explicit one, if the semantic 
actions will it so.

match(for)
match('(')
match(optexpr) -> match(ε)
match(';')
match(optexpr) -> match(expr)
match(';')
match(optexpr) -> match(expr)
match(')')
match(stmt) -> match(other)

every time we match a terminal we can advance the lookahead symbol
e.g. if (match(lookahead, ';')) 
        lookahead = next();

a _translation scheme_ is formed by extending a _grammar_ (adding semantic actions to it)
a _syntax directed translator_ is formed by extending a _predictive parser_

left recursive productions can cause a recursive-descent parser to loop forever:
expr: expr + term
void expr() {
    expr()
    match(+)
    term()
}




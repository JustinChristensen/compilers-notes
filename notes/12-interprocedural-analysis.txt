Interprocedural Analysis

- for programming languages like C or Java pointer aliasing is key to analyzing interprocedural analysis
- datalog, a notation that greatly hides the complexity of efficient pointer analysis
- BDD, binary decision diagram
- most compiler optimizations performed on the contents of procedures, one at a time
- these optimizations are known as intra-procedural analysis
- inter-procedural analysis operate across the entire program
- inlining replaces the invocation of a procedure with the body of the procedure itself
- this method can only be used if we know the target of the procedure call
- if procedures are invoked indirectly through a pointer, analysis can in some cases determine the unique target of the invocation for inlining

Basic Concepts
- call graphs, which procedure calls which
- context sensitivity requires that data-flow analysis determine the order of procedure calls
- a call graph is a set of nodes and edges such that
    * there are nodes for procedures in the program
    * and nodes for individual call sites
    * if call site c may call procedure p, then there is an edge from c to p
- for static invocations, there is exactly one edge from a call site to a procedure (a call site has one and belongs to a procedure)
- for dynamic invocations, like those through a function pointer or function parameter, there may be potentially many edges from a single call site to the procedures in the graph
- indirect calls are the norm for OOP languages
- virtual method invocations requires the type of the receiver object before we can determine which procedure is being invoked
- the presence of indirect calls through pointers to procedures requires us to do interprocedural analysis to determine the values that the pointers can take on through the life of the program

Context Sensitivity
- the main challenge of inter-procedural analysis is that each procedure is dependent upon it's context.
- context-insensitive analysis treats each call and return as goto operations.
- to do this, we create an alternate control flow graph where
    * call sites have edges to the beginning of the procedure being called (as if a goto)
    * edges leading back from the return statement back to the instruction after the call site
- the string of call sites on the stack is known as the call string
- for situations where we may have an unbounded number of calls, such as recursive invocation, we can use a technique to limit the context
    called k-limiting the call string (just use the k most recent calls)
- another option is to be fully context-sensitive for acyclic call strings, and k-limited for cyclic ones

Cloning-Based Context-Sensitive Analysis
- another option is to clone the procedure for each unique context of interest
- in reality, we attach multiple instances of context information to a single procedure

Summary-Based Context-Sensitive Analysis
- each procedure has a summary attached that describes some observable behavior about the procedure
- compute the transfer function for regions and attach it as a summary to the procedure
- then walk through the call graph and compute the effect of the computation

Why?
- for virtual method invocation in an OOP language we can identify commonly-used receiver types and potentially inline that type's instance of the method.
- we can improve intraprocedural analysis to determine whether or not pointers are aliases of variables
- identify further routines for parallelization
- static analysis to avoid bugs
- detecting buffer overflows

Logical Representation of Data Flow
- rather than expressing "definition D is in set IN[B]" we use notation like in(B, D)
- it generalizes the bit-vector approach to set operations

Datalog
- a language that uses Prolog-like notation
- elements of Datalog are atoms of the form p(X1, X2, ..., Xn)
- p is a predicate that represents a statement such as "a definition reaches the beginning of a block"
- X1, ... are terms such as variables or constants, or simple expressions
- a ground atom is a predicate with only constants as arguments
- a predicate can be represented by a relation, that is, a table of it's true ground atoms
- each row is a tuple of the relation
- each ground atom (row) in a relation is true

For example, predicate in(B, D) means "definition D reaches the beginning of block B"
    B | D
   -------
    a | w       definition w reaches the beginning of block a
    b | y
    c | z

- comparison predicates operate differently than the above "fact" atoms
- A literal is either an atom or a negated atom
- NOT in(B, D)
- variables begin with a capital letter, other symbols don't

SEE: https://en.wikipedia.org/wiki/Datalog

- rules have the form H :- B1 & B2 & B3 & ... & Bn
- where the B's are subgoals of the head, H, of the rule
- "the head is true if the body is true"
- facts can then be composed of other facts, but if one of the subgoals in the body is not a fact (perhaps it's a comparison), then we can't determine that the header is a fact

Directed graph example:
path(X, Y) :- edge(X, Y)                # fact "there is a path from x to y because there is an edge from x to y
path(X, Y) :- path (X, Z) & path(Z, Y)  # fact "there is a path from x to y, because there is a path from x to z, and a path from z to y"
    # transitive closure

- some predicates are assumes to exist beforehand, and are known as EDB or extensional database predicates
- IDB, or intensional database predicates, are defined by the rules of the Datalog program

def(b1, 1, x)       # x is defined at position 1 in block b1
def(b1, 2, Y)       # any possible variable, Y, is defined at point 2 in b1
succ(B, N, C)       # true if block C is a successor of block B in the flow graph, and B has N statements
rd(B, N, C, M, X)   # true if variable X, at statement M, in block C, reaches point N, in block B







